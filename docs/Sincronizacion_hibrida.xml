<?xml version="1.0" encoding="UTF-8"?>
<plan_sincronizacion_hibrida>
  
  <!-- FASE 1: MEJORAR PROTECCI√ìN DE CACHE -->
  <fase id="1" titulo="Optimizar l√≥gica de cache en use-app-actions">
    <descripcion>
      Modificar la condici√≥n de protecci√≥n para verificar que TODOS los datos cr√≠ticos 
      est√©n presentes antes de saltar la recarga
    </descripcion>
    <archivo>src/hooks/use-app-actions.ts</archivo>
    <lineas>22-25</lineas>
    <cambio_tipo>enhancement</cambio_tipo>
    <logica_actual>
      if (!forceReload && user?.id === userId && user.total_checkins !== undefined)
    </logica_actual>
    <logica_nueva>
      if (!forceReload && user?.id === userId && 
          user.total_checkins !== undefined && 
          user.current_streak !== undefined &&
          user.available_spins !== undefined)
    </logica_nueva>
    <beneficio>Previene uso de datos incompletos, permite sincronizaci√≥n cuando faltan campos cr√≠ticos</beneficio>
  </fase>

  <!-- FASE 2: SINCRONIZACI√ìN INICIAL INTELIGENTE -->
  <fase id="2" titulo="Implementar sync inicial en RealtimeInitializer">
    <descripcion>
      Agregar useEffect que detecte datos incompletos y ejecute loadUserData autom√°ticamente
    </descripcion>
    <archivo>src/components/providers/RealtimeInitializer.tsx</archivo>
    <ubicacion>Despu√©s de useRealtimeManager()</ubicacion>
    <cambio_tipo>new_feature</cambio_tipo>
    <implementacion>
      <importar>useUser, useAppDispatch from '@/store/hooks'</importar>
      <importar>loadUserProfile from '@/store/slices/authSlice'</importar>
      <logica>
        useEffect(() => {
          if (user?.id && (
            user.current_streak === undefined || 
            user.available_spins === undefined ||
            user.total_checkins === undefined
          )) {
            console.log('üîÑ Datos incompletos detectados, sincronizando...')
            dispatch(loadUserProfile(user.id))
          }
        }, [user?.id, user?.current_streak, user?.available_spins, user?.total_checkins])
      </logica>
    </implementacion>
    <beneficio>Datos siempre frescos al montar app, soluciona navegaci√≥n directa y recargas</beneficio>
  </fase>

  <!-- FASE 3: MEJORAR PULL-TO-REFRESH -->
  <fase id="3" titulo="Integrar datos cr√≠ticos en pull-to-refresh">
    <descripcion>
      Incluir loadUserProfile en handleRefresh para que pull-to-refresh tambi√©n refresque datos realtime
    </descripcion>
    <archivo>src/components/client/AppShell.tsx</archivo>
    <lineas>60-75</lineas>
    <cambio_tipo>enhancement</cambio_tipo>
    <logica_agregar>
      // Refrescar datos del usuario (cr√≠ticos realtime)
      dispatch(loadUserProfile(user.id)),
    </logica_agregar>
    <ubicacion>Dentro del Promise.all() existente</ubicacion>
    <beneficio>Pull-to-refresh se vuelve √∫til para datos realtime, coherencia con sync inicial</beneficio>
    <nota>Mantiene la filosof√≠a actual pero extiende funcionalidad</nota>
  </fase>

  <!-- FASE 4: DEBUGGING Y MONITOREO -->
  <fase id="4" titulo="Agregar logging inteligente">
    <descripcion>
      A√±adir logs informativos para monitorear comportamiento de sincronizaci√≥n
    </descripcion>
    <ubicaciones>
      <archivo>src/hooks/use-app-actions.ts</archivo>
      <archivo>src/components/providers/RealtimeInitializer.tsx</archivo>
    </ubicaciones>
    <cambio_tipo>debugging</cambio_tipo>
    <logs_agregar>
      - "üîÑ Sincronizaci√≥n inicial: datos incompletos detectados"
      - "‚úÖ Cache hit: datos completos, usando Redux"
      - "üîÑ Pull-to-refresh: incluyendo datos cr√≠ticos"
      - "‚úÖ Sincronizaci√≥n completada: datos frescos cargados"
    </logs_agregar>
    <beneficio>Visibilidad del comportamiento, debugging f√°cil</beneficio>
  </fase>

  <!-- FASE 5: TESTING Y VALIDACI√ìN -->
  <fase id="5" titulo="Testing completo del flujo">
    <descripcion>
      Probar todos los escenarios cr√≠ticos para validar funcionamiento
    </descripcion>
    <escenarios_testing>
      <escenario id="1">Navegaci√≥n directa a URL con app cerrada</escenario>
      <escenario id="2">Recarga de p√°gina (F5)</escenario>
      <escenario id="3">P√©rdida y reconexi√≥n de red</escenario>
      <escenario id="4">Pull-to-refresh manual</escenario>
      <escenario id="5">Cambio de datos en otro dispositivo (realtime)</escenario>
      <escenario id="6">Logout/login (control baseline)</escenario>
    </escenarios_testing>
    <metricas_validacion>
      - Datos siempre frescos al cargar
      - Realtime funciona para updates posteriores
      - No consultas duplicadas innecesarias
      - Pull-to-refresh √∫til y funcional
    </metricas_validacion>
  </fase>

  <!-- CONFIGURACI√ìN PULL-TO-REFRESH -->
  <pull_to_refresh_strategy>
    <filosofia>
      S√ç incluir datos cr√≠ticos en pull-to-refresh porque:
      - Mantiene coherencia con sincronizaci√≥n inicial
      - Ofrece refresh manual cuando usuario lo necesita
      - No contradice realtime (es complementario)
      - Hace la funci√≥n realmente √∫til
    </filosofia>
    <implementacion>
      Agregar dispatch(loadUserProfile(user.id)) en el Promise.all() existente
      junto con las invalidaciones actuales de datos est√°ticos
    </implementacion>
    <beneficio>
      Pull-to-refresh se convierte en "refresh completo" incluyendo tanto 
      datos est√°ticos como datos cr√≠ticos realtime
    </beneficio>
  </pull_to_refresh_strategy>

  <!-- RESULTADO ESPERADO -->
  <resultado_final>
    <escenario name="navegacion_directa">‚úÖ Datos frescos autom√°ticamente</escenario>
    <escenario name="recarga_pagina">‚úÖ Datos frescos autom√°ticamente</escenario>
    <escenario name="cambios_realtime">‚úÖ Updates instant√°neos v√≠a realtime</escenario>
    <escenario name="pull_to_refresh">‚úÖ Refresh completo (est√°ticos + cr√≠ticos)</escenario>
    <escenario name="perdida_conexion">‚úÖ Re-sync al reconectar</escenario>
    <compatibilidad>‚úÖ Mantiene toda la l√≥gica y principios actuales</compatibilidad>
  </resultado_final>

</plan_sincronizacion_hibrida>